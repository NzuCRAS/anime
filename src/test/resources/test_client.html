<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Anime - 测试客户端 (login / presign / upload / diary)</title>
    <style>
        body { font-family: Arial, Helvetica, sans-serif; padding: 20px; max-width: 900px; margin: auto; }
        input, button, textarea { font-size: 14px; margin: 4px 0; }
        .box { border: 1px solid #ddd; padding: 12px; margin: 12px 0; border-radius: 6px; }
        .log { white-space: pre-wrap; background: #f7f7f7; padding: 8px; border-radius: 4px; max-height: 240px; overflow:auto; }
        label { display:block; margin-top:8px; }
    </style>
</head>
<body>
<h2>测试客户端：登录 / whoami / presign 上传 / 保存日记</h2>

<div class="box">
    <h3>1) 登录（会写 refreshToken cookie，返回 access token 到 header）</h3>
    <label>用户名或邮箱：<input id="username" value="test_name"></label>
    <label>密码：<input id="password" type="password" value="test_password"></label>
    <button id="btnLogin">登录 (POST /api/user/login)</button>
    <p>说明：登录后会把 access token 存到内存 (accessToken)，refresh token 写入 HttpOnly cookie。</p>
</div>

<div class="box">
    <h3>2) 刷新 access token（使用 refresh cookie）</h3>
    <button id="btnRefresh">刷新 (POST /api/auth/refresh)</button>
    <p>说明：请求会带 cookie（需 credentials: 'include'），服务器从 refreshToken cookie 读取并返回新的 access token。</p>
</div>

<div class="box">
    <h3>2.1) WhoAmI - 验证当前 token 是否生效</h3>
    <p>调用 GET /api/test/whoami（依赖 Authorization header），用于快速验证当前 access token 是否被后端接受并注入 @CurrentUser。</p>
    <button id="btnWhoami">WhoAmI</button>
    <p>说明：若返回 userId=... 表示 token 生效；若返回 401 表示认证未通过。</p>
</div>

<div class="box">
    <h3>3) 选择图片并获取 presign 上传 URL</h3>
    <input type="file" id="fileInput" accept="image/*">
    <label>原始文件名（可选）：<input id="origName" placeholder="保留原文件名用于 metadata"></label>
    <button id="btnPresignUpload">获取 presign 并上传</button>
    <p>上传完成后会显示 attachmentId（请记住用于保存日记时传回后端）</p>
</div>

<div class="box">
    <h3>4) 保存日记（POST /api/diaries）</h3>
    <label>Diary Title: <input id="diaryTitle" value="测试日记"></label>
    <label>Diary ID (更新时填写): <input id="diaryId" placeholder="留空表示新建"></label>
    <label>Diary Version (更新时填写): <input id="diaryVersion" placeholder="更新用"></label>

    <h4>Blocks JSON (示例)</h4>
    <textarea id="blocksJson" rows="6" style="width:100%;">[
  {"blockId": null, "type":"text","content":"这是一个测试文本块","attachmentId":null,"metadata":null},
  {"blockId": null, "type":"image","content":null,"attachmentId":null,"metadata":null}
]</textarea>
    <p>提示：如果你的 image block 用到了刚上传的 attachmentId，请把 JSON 中对应 attachmentId 替换为该 id。</p>
    <button id="btnSaveDiary">保存日记 (POST /api/diaries)</button>
</div>

<div class="box">
    <h3>5) 获取日记（GET /api/diaries/{id}）</h3>
    <label>Diary ID: <input id="qryDiaryId"></label>
    <button id="btnGetDiary">获取</button>
</div>

<div class="box">
    <h3>日志 / 响应</h3>
    <div id="log" class="log"></div>
</div>

<script>
    /*
      简单客户端逻辑：
      - accessToken 保存在内存变量 currentAccessToken
      - 登录请求需要 credentials: 'include' 以便服务端写 refresh cookie
      - refresh 也需要 credentials: 'include'
      - presign 上传：如果后端要求 Authorization，可在请求头加入 Authorization
      - 上传 PUT 到 presigned URL 时通常不要带 Authorization（使用 presigned url），但需要设置返回的 putHeaders
    */

    let currentAccessToken = null;
    const BASE = 'https://localhost:8443';

    function log(msg) {
        const el = document.getElementById('log');
        const now = new Date().toISOString();
        el.textContent = `${now}  ${msg}\n\n` + el.textContent;
    }

    // helper to add Authorization header if we have token
    function authHeaders() {
        const headers = {};
        if (currentAccessToken) headers['Authorization'] = 'Bearer ' + currentAccessToken;
        return headers;
    }

    // Login
    document.getElementById('btnLogin').addEventListener('click', async () => {
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        try {
            const res = await fetch(`${BASE}/api/user/login`, {
                method: 'POST',
                credentials: 'include', // allow refresh cookie to be written
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ usernameOrEmail: username, password })
            });
            const text = await res.text();
            log(`[login] status=${res.status} body=${text}`);
            // New-Access-Token header may contain access token (front should sync it into memory)
            const newAccess = res.headers.get('New-Access-Token');
            if (newAccess) {
                currentAccessToken = newAccess;
                log('[login] got New-Access-Token header -> saved to memory');
            } else {
                // maybe returned in body as JSON; try parse
                try {
                    const json = JSON.parse(text);
                    const bodyToken = json?.data?.accessToken || json?.accessToken;
                    if (bodyToken) {
                        currentAccessToken = bodyToken;
                        log('[login] got accessToken from body -> saved to memory');
                    }
                } catch (e) {}
            }
        } catch (e) {
            log('[login] error: ' + e.message);
        }
    });

    // Refresh
    document.getElementById('btnRefresh').addEventListener('click', async () => {
        try {
            const res = await fetch(`${BASE}/api/auth/refresh`, {
                method: 'POST',
                credentials: 'include', // must send refresh cookie
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'  // 标识为 AJAX 请求
                }
            });
            const json = await res.json().catch(()=>null);
            log(`[refresh] status=${res.status} body=${JSON.stringify(json)}`);
            // server returns access token in body (data.accessToken) or New-Access-Token header
            const headerToken = res.headers.get('New-Access-Token');
            if (headerToken) {
                currentAccessToken = headerToken;
                log('[refresh] got New-Access-Token -> saved to memory');
            } else if (json && json.data && json.data.accessToken) {
                currentAccessToken = json.data.accessToken;
                log('[refresh] got accessToken in body -> saved to memory');
            }
        } catch (e) {
            log('[refresh] error: ' + e.message);
        }
    });

    // WhoAmI
    document.getElementById('btnWhoami').addEventListener('click', async () => {
        try {
            const res = await fetch(`${BASE}/api/test/whoami`, {
                method: 'GET',
                headers: Object.assign({}, authHeaders()),
                credentials: 'include'
            });
            const text = await res.text().catch(()=>null);
            log(`[whoami] status=${res.status} body=${text}`);
        } catch (e) {
            log('[whoami] error: ' + e.message);
        }
    });

    // Presign + Upload（替换原来的同名 handler）
    document.getElementById('btnPresignUpload').addEventListener('click', async () => {
        const f = document.getElementById('fileInput').files[0];
        if (!f) {
            alert('请选择文件');
            return;
        }
        const orig = document.getElementById('origName').value || f.name;
        const contentType = f.type || 'application/octet-stream';

        // 构造和后端 AttachmentController.PresignRequest 对应的 body
        const presignReq = {
            storagePath: null,          // 后端会自行生成 storageKey，传 null 或空
            originalFilename: orig,
            contentType: contentType,
            uploadedBy: null,           // 前端不传 userId（后端从 token 或上下文决定），可传 null
            width: null,
            height: null
        };

        try {
            // 请求 presign
            const res = await fetch(`${BASE}/api/attachments/presign`, {
                method: 'POST',
                credentials: 'include', // allow cookie if needed by server-side auth
                headers: Object.assign({'Content-Type': 'application/json'}, authHeaders()),
                body: JSON.stringify(presignReq)
            });

            // 注意：AttachmentController 返回 PresignResponseDTO（未包在统一 Result 中）
            const resp = await res.json();
            log(`[presign] status=${res.status} body=${JSON.stringify(resp)}`);

            if (!res.ok) {
                log('[presign] presign failed: ' + JSON.stringify(resp));
                return;
            }

            // resp 是直接的 PresignResponseDTO 或包含字段
            const attachmentId = resp.attachmentId || resp.attachment_id || resp.id;
            const putUrl = resp.putUrl || resp.put_url || resp.put_url;
            const putHeaders = resp.putHeaders || resp.put_headers || resp.headers || {};

            if (!putUrl || !attachmentId) {
                log('[presign] invalid response, missing putUrl or attachmentId');
                return;
            }

            log(`[presign] got attachmentId=${attachmentId} putUrl=${putUrl}`);

            // 上传到 presigned URL
            // 构造 PUT headers（需要严格匹配服务器签名）
            const uploadHeaders = {};
            for (const k in putHeaders) {
                if (!Object.prototype.hasOwnProperty.call(putHeaders, k)) continue;
                uploadHeaders[k] = putHeaders[k];
            }
            uploadHeaders['Content-Type'] = contentType;

            const uploadRes = await fetch(putUrl, {
                method: 'PUT',
                headers: uploadHeaders,
                body: f,
                // credentials: 'omit' 通常是默认，但不要发带 cookie 到存储域
            });

            log(`[upload] PUT -> status=${uploadRes.status} ${uploadRes.statusText}`);
            if (!uploadRes.ok) {
                const text = await uploadRes.text().catch(()=>null);
                log('[upload] upload failed; response text: ' + text);
                return;
            }

            log(`[upload] upload successful. attachmentId=${attachmentId}`);

            // 上传完成后，调用 /api/attachments/complete 通知后端（AttachmentController 提供）
            try {
                const completeRes = await fetch(`${BASE}/api/attachments/complete`, {
                    method: 'POST',
                    credentials: 'include',
                    headers: Object.assign({'Content-Type': 'application/json'}, authHeaders()),
                    body: JSON.stringify({ attachmentId })
                });
                const completeBody = await completeRes.json().catch(()=>null);
                log(`[complete] status=${completeRes.status} body=${JSON.stringify(completeBody)}`);
                if (completeRes.ok) {
                    // 自动把 attachmentId 填回 blocksJson 的第一个空 attachmentId 处，便于后续保存
                    const blocksEl = document.getElementById('blocksJson');
                    try {
                        const arr = JSON.parse(blocksEl.value);
                        for (let i = 0; i < arr.length; i++) {
                            if (arr[i].attachmentId == null) {
                                arr[i].attachmentId = attachmentId;
                                break;
                            }
                        }
                        blocksEl.value = JSON.stringify(arr, null, 2);
                    } catch(e) {}
                } else {
                    log('[complete] finalize failed: ' + JSON.stringify(completeBody));
                }
            } catch (e) {
                log('[complete] error: ' + e.message);
            }

        } catch (e) {
            log('[presign/upload] error: ' + e.message);
        }
    });

    // Save Diary
    document.getElementById('btnSaveDiary').addEventListener('click', async () => {
        const title = document.getElementById('diaryTitle').value;
        const diaryId = document.getElementById('diaryId').value || null;
        const diaryVersion = document.getElementById('diaryVersion').value || null;
        let blocks;
        try {
            blocks = JSON.parse(document.getElementById('blocksJson').value);
        } catch (e) {
            alert('blocksJson 不是合法的 JSON');
            return;
        }
        // build diary object
        const diary = {};
        if (diaryId) diary.id = Number(diaryId);
        if (diaryVersion) diary.version = Number(diaryVersion);
        diary.title = title;

        const payload = { diary, blocks };

        try {
            const res = await fetch(`${BASE}/api/diaries`, {
                method: 'POST',
                headers: Object.assign({'Content-Type': 'application/json'}, authHeaders()),
                credentials: 'include', // include so server can access cookie if finalize uses cookie-sensitive ops
                body: JSON.stringify(payload)
            });
            const data = await res.json().catch(()=>null);
            log(`[saveDiary] status=${res.status} body=${JSON.stringify(data)}`);
            if (res.status === 200) {
                // update local diary id/version and block ids if returned
                const result = data && data.data ? data.data : data;
                // result likely has diary and blocks (your SaveResult)
                if (result && result.diary) {
                    document.getElementById('diaryId').value = result.diary.id || '';
                    document.getElementById('diaryVersion').value = result.diary.version || '';
                }
                if (result && result.blocks) {
                    document.getElementById('blocksJson').value = JSON.stringify(result.blocks, null, 2);
                }
            } else if (res.status === 409) {
                alert('版本冲突，请刷新页面并合并修改');
            }
        } catch (e) {
            log('[saveDiary] error: ' + e.message);
        }
    });

    // Get Diary
    document.getElementById('btnGetDiary').addEventListener('click', async () => {
        const id = document.getElementById('qryDiaryId').value;
        if (!id) { alert('请输入 diary id'); return; }
        try {
            const res = await fetch(`${BASE}/api/diaries/${id}`, {
                method: 'GET',
                headers: authHeaders(),
                credentials: 'include'
            });
            const data = await res.json().catch(()=>null);
            log(`[getDiary] status=${res.status} body=${JSON.stringify(data)}`);
            if (res.status === 200 && data) {
                // populate fields for convenience
                const result = data.data ? data.data : data;
                if (result.diary) {
                    document.getElementById('diaryId').value = result.diary.id || '';
                    document.getElementById('diaryTitle').value = result.diary.title || '';
                    document.getElementById('diaryVersion').value = result.diary.version || '';
                }
                if (result.blocks) {
                    document.getElementById('blocksJson').value = JSON.stringify(result.blocks, null, 2);
                }
            }
        } catch (e) {
            log('[getDiary] error: ' + e.message);
        }
    });

    // show current access token for debugging (not persisted)
    setInterval(() => {
        log('[debug] currentAccessToken=' + (currentAccessToken ? ('***' + currentAccessToken.slice(-8)) : 'null'));
    }, 60000); // 每60s输出一次，避免频繁

</script>
</body>
</html>